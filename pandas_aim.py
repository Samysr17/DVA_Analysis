# -*- coding: utf-8 -*-
"""Pandas_aim.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GZbiWdzRamyFhIWtWIyFlR8KLB6hGMV6
"""

from google.colab import files
files.upload()

"""Load the iris data from a given csv file into a data frame and print the shape of
the data, type of the data and first and last 4 rows
"""

import pandas as pd
data=pd.read_csv("Iris_nonull (1).csv")
print(data)
print(type(data))
print(data.head(10))
print(data.tail(10))
print(data.info())

"""Describe the dataset, and find number of observations, missing values and
nan values
"""

data.describe().T

print("Total Missing Values : ",data.isnull().sum().sum())
print("In respective columns are : \n",data.isnull().sum())

import numpy as np
d1=data.replace("??",np.nan)
d1=data.replace("##",np.nan)
d1=data.replace("??",np.nan)
d1

for i in d1.columns[:4]:
 d1[i] = pd.to_numeric(d1[i],errors='coerce')
d1.info()

"""View basic statistical details like percentile, mean, std deviation, mode,
variance, skewness and kutosis of iris data
"""

d1

d1.mean()

d1.var()

np.sqrt(d1.var())#std deviation

d1.skew()

d1.describe().T

d1.kurtosis()

"""View basic statistical details like percentile, mean, std deviation, mode,
variance, skewness and kutosis of each species (setosa, versicolor, virginica)
from iris data.
"""

l=["Iris-setosa","Iris-versicolor","Iris-virginica"]
for i in l:
 df2 = d1.loc[d1["Species"] == i]
print("SPECIES IS : ",i)
print(df2.describe().transpose())
print("MEDIAN: ",df2.median()) #median
print("VARIANCE: ",df2.var()) #variance
print("STD_DEVIATION: ",np.sqrt(df2.var())) #std deviation
print("SKEW: ",df2.skew()) #skewness
print("KUTOSIS: ",df2.kurtosis())

"""Drop Id column from a given Dataframe and print the modified part"""

df2 = d1.reset_index()
df2 = d1
df2 = df2.drop("Id",axis=1)
df2

"""Print the species and row number having maximum Sepal Length."""

l1=[]
for x in data["SepalLengthCm"]:
  l1.append(x)

print(l1)
print("Maximum sepal length is:",max(l1))

data.loc[data["SepalLengthCm"] == 7.9]

"""Print the Species and row number having minimum Petal Width."""

l=[]
for x in d1["PetalWidthCm"]:
  l.append(x)

print(l)
print(min(l))

d1.loc[d1["PetalWidthCm"] == 0.1]

"""Replace missing values of Petal Width by mean of Petal Width and Sepal
Length by mode of Sepal Length column.
"""

df5 = d1
m1 = df5["PetalWidthCm"].mean()
print(m1)
df5['PetalWidthCm'] = df5['PetalWidthCm'].fillna(m1)

"""Sort all the rows by Sepal Length column"""

df4 = d1
df4.sort_values(by = ['SepalLengthCm'])

"""Perform correlation analysis on Petal width and Petal Length using Pearson
Correlation Coefficient. (using library scipy.stat and without using library)
(theory on the same is given below)
"""

df5[['PetalLengthCm','PetalWidthCm']].corr(method = 'pearson')

from scipy import stats as st
df6 = df5[['PetalLengthCm','PetalWidthCm']].dropna()
res = st.pearsonr(df6['PetalLengthCm'],df6['PetalWidthCm'])
res

df6 = df5[['PetalLengthCm','PetalWidthCm']].dropna()
x = df6['PetalLengthCm']
y = df6['PetalWidthCm']
xy = df6['PetalLengthCm']*df6['PetalWidthCm']
xx = df6['PetalLengthCm']* df6['PetalLengthCm']
yy = df6['PetalWidthCm']*df6['PetalWidthCm']
n = len(x)
r = (n*(sum(xy)) - (sum(x))*(sum(y)))
q = (((n*sum(xx))-(sum(x))*(sum(x)))*((n*sum(yy))-(sum(y))*(sum(y))))
r = r/np.sqrt(q)
r

"""12. (Define any complex task on iris dataset)
13. (Define any complex task on iris dataset)
14. (Define any complex task on iris dataset)
15. (Define any complex task on iris dataset)
"""

data = df5.drop_duplicates(subset='Species',)
data
#dropping duplicates

"""Data visualisation using matplotlib and seaborn"""

import seaborn as sns
import matplotlib.pyplot as plt
sns.countplot(x='Species', data=df5, )
plt.show()

sns.scatterplot(x='SepalLengthCm', y='SepalWidthCm',hue='Species', data=d1, )
plt.legend(bbox_to_anchor=(1, 1))
plt.show()

plt.bar(x,y,color="orange")
plt.show()

"""The interpolate() function uses existing values in the DataFrame to estimate the missing rows. Setting the inplace keyword to True alters the
DataFrame permanently.
"""

print(d1.interpolate(method ='linear', limit_direction ='backward'))

import pandas as pd
help(pd)

